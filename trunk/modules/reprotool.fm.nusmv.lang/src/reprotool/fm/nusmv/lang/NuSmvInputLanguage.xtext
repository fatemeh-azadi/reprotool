grammar reprotool.fm.nusmv.lang.NuSmvInputLanguage with org.eclipse.xtext.common.Terminals

generate nuSmvInputLanguage "http://www.fm.reprotool/nusmv/lang/NuSmvInputLanguage"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model hidden(WS, SL_COMMENT): (modules+=Module)*;

Module:
	"MODULE" name=ID ("(" (params+=FormalParameter) ("," params+=FormalParameter)* ")")?
		(moduleElement+=ModuleElement)*
;

ModuleElement hidden(WS, SL_COMMENT):
	VariableDeclaration |
	IVariableDeclaration |
	FrozenVariableDeclaration |
	DefineDeclaration |
	ConstantsDeclaration |
	AssignConstraint |
	TransConstraint |
	InitConstraint |
	InvarConstraint |
	FairnessConstraint |
	CtlSpecification  |
	LtlSpecification |
	InvarSpecification |
	IsaDeclaration
;

//Also the single keyword "VAR" is accepted (without anything else)
VariableDeclaration hidden(WS, SL_COMMENT):
var="VAR" (vars+=VarBody)*
;

IVariableDeclaration hidden(WS, SL_COMMENT):
"IVAR" (vars+=VarBody)+
;

FrozenVariableDeclaration  hidden(WS, SL_COMMENT):
"FROZENVAR" (vars+=VarBody)+
;

VarBody hidden(WS, SL_COMMENT):
	id=ID ":" type=Type semicolon ?= ";"
;

DefineDeclaration hidden(WS, SL_COMMENT):
define="DEFINE" (defineBodies+=DefineBody)*
;

DefineBody hidden(WS, SL_COMMENT):
var=VariableIdentifier ":=" assignment=SimpleExpression semicolon ?= ";"
;

ConstantsDeclaration hidden(WS, SL_COMMENT):
"CONSTANTS" constants+=ID ("," constants+=ID)* semicolon ?= ";"
;

AssignConstraint hidden(WS, SL_COMMENT): assign="ASSIGN"
	(bodies+=AssignBody)*
;

AssignBody hidden(WS, SL_COMMENT):
	VarBodyAssign | InitBody | NextBody
;

VarBodyAssign returns VarBodyAssign hidden(WS, SL_COMMENT):
var=VariableIdentifier ":=" assignment=SimpleExpression semicolon ?= ";"
;

InitBody returns AssignBodyInit hidden(WS, SL_COMMENT):
"init" "(" var=VariableIdentifier ")" ":=" initial=SimpleExpression semicolon ?= ";"
;

NextBody returns NextBody hidden(WS, SL_COMMENT):
"next" "(" var=VariableIdentifier ")" ":=" next=NextExpression semicolon ?= ";"
;

TransConstraint hidden(WS, SL_COMMENT):
"TRANS" transExpression=SimpleExpression semicolon ?= ";"?
;

InitConstraint hidden(WS, SL_COMMENT):
"INIT" initExpression=SimpleExpression semicolon ?= ";"?
;

InvarConstraint hidden(WS, SL_COMMENT):
"INVAR" invarExpression=SimpleExpression semicolon ?= ";"?
;

FairnessConstraint hidden(WS, SL_COMMENT):
FairnessExpression | JusticeExpression | CompassionExpression
;

FairnessExpression hidden(WS, SL_COMMENT):
"FAIRNESS" fairnessExpr=SimpleExpression semicolon ?= ";"?
;

JusticeExpression hidden(WS, SL_COMMENT):
"JUSTICE" justiceExpr=SimpleExpression semicolon ?= ";"?
;

CompassionExpression hidden(WS, SL_COMMENT):
"COMPASSION (" firstCompassionExpr=SimpleExpression "," secondCompassionExpr=SimpleExpression ")" semicolon ?= ";"?
;

CtlSpecification hidden(WS, SL_COMMENT) :
	specKeyWord=("CTLSPEC" | "SPEC") (nameKeyWord?="NAME" name=ID ":=")? ctlExpression=CTLExpression semicolon?=";"?
;

InvarSpecification hidden(WS, SL_COMMENT) :
"INVARSPEC" invarSpec=NextExpression ";" |
"INVARSPEC" name=ID ":=" invarSpec=NextExpression semicolon?=";"?
;

IsaDeclaration hidden(WS, SL_COMMENT): "ISA" id=ID;

LtlSpecification hidden(WS, SL_COMMENT) :
	"LTLSPEC" (nameId?="NAME" name=ID ":=")? ltlExpression=LTLExpression semicolon ?=";"?
;

Type hidden(WS, SL_COMMENT): SimpleType | ModuleType;

SimpleType hidden(WS, SL_COMMENT):
	{BooleanType} "boolean"
	| {WordType} ("word" "[" wordNumber=NUMBER "]") 
	| {UnsignedWordType} ("unsigned" "word" "[" uWordNumber=NUMBER "]")
	| {SignedWordType} ("signed word" "[" signedNumber=NUMBER "]")
	| {EnumType} "{" val+=Val ("," val+=Val)* "}"
	| {IntervalType} (low = NUMBER ".." high = NUMBER)
	| {ArrayType} "array" lowerBound=NUMBER ".." upperBound=NUMBER "of" type=SimpleType
;

ModuleType hidden(WS, SL_COMMENT):
{AsyncrProcessType} ("process" module=[Module | ID] ("(" params+=SimpleExpression ("," params+=SimpleExpression)* ")")?)
| {SyncrProcessType} (module=[Module| ID] ("(" params+=SimpleExpression ("," params+=SimpleExpression)* ")")?);

Val hidden(WS, SL_COMMENT): ID | NUMBER | BOOLEAN_CONSTANT;

NextExpression hidden(WS, SL_COMMENT):
	simpleExpression=SimpleExpression
;

FormalParameter: id=ID;

CTLExpression hidden(WS, SL_COMMENT): simpleExpression=SimpleExpression;
LTLExpression hidden(WS, SL_COMMENT): simpleExpression=SimpleExpression;

RangeExpression: lower = NUMBER ".." upper = NUMBER;

VariableIdentifier hidden(WS, SL_COMMENT):
 TerminalVariableIdentifier ("." TerminalVariableIdentifier)*
| TerminalVariableIdentifier ("[" (NUMBER | TerminalVariableIdentifier) "]")+
| TerminalVariableIdentifier "[" NUMBER ":" NUMBER"]"
;

TerminalVariableIdentifier hidden(WS, SL_COMMENT): ID;

SimpleExpression hidden(WS, SL_COMMENT):
	InfixExpression;

InfixExpression:
	TerminalSimpleExpression (('U'|'V'|'S'|'T'|'->'|'<->'|'&'|'|'|'xor'|'xnor'|'='|'!='|'<'|'>'|'<='|'>='|'+'|'-'|'*'|'/'|'::'|'<<'|'>>'|'union'|'in'|'mod') TerminalSimpleExpression)*;

TerminalSimpleExpression:
	'!'? (
		'next'? '(' SimpleExpression ')'
	    | (('-' | '+' | 'EG' | 'EX' | 'EF' | 'AG' | 'AX' | 'AF' | 'X' | 'G' | 'F' | 'Y' | 'Z' | 'H' | 'O') SimpleExpression)
	    | CaseSimpleExpression
	    | VariableIdentifier
	    | NUMBER
		| NUMBER '..' NUMBER
		| BOOLEAN_CONSTANT
		| 'self'
		| '{' SimpleExpression (',' SimpleExpression)* '}'
		| ('E' | 'A') '[' InfixExpression ']'
		| ('word1' | 'boo1') '(' SimpleExpression ')'
	)
;

CaseSimpleExpression hidden(WS, SL_COMMENT):
	'case'
	(SimpleExpression ':' SimpleExpression ';')+
	'esac'
;

terminal NUMBER : INT;
terminal SL_COMMENT : '--' !('\n'|'\r')* ('\r'? '\n')? ;
terminal ID : ('A'..'Z'|'a'..'z'|'_') ('A'..'Z'|'a'..'z'|'_'|'0'..'9'|'$'|'#'|'-'|'.')*;
terminal BOOLEAN_CONSTANT : 'TRUE' | 'FALSE';