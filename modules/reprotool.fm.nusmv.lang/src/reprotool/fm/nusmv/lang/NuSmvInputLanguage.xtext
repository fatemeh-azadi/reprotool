grammar reprotool.fm.nusmv.lang.NuSmvInputLanguage with org.eclipse.xtext.common.Terminals

generate nuSmvInputLanguage "http://www.fm.reprotool/nusmv/lang/NuSmvInputLanguage"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model hidden(WS, SL_COMMENT): (modules+=Module)*;

Module:
	"MODULE" (MainModule | OtherModule)
	(moduleElement+=ModuleElement)*;

MainModule: {MainModule}
	name='main';
	
OtherModule:
	name=ID ("(" (params+=FormalParameter) ("," params+=FormalParameter)* ")")?;

ModuleElement hidden(WS, SL_COMMENT):
	VariableDeclaration |
	IVariableDeclaration |
	FrozenVariableDeclaration |
	DefineDeclaration |
	ConstantsDeclaration |
	AssignConstraint |
	TransConstraint |
	InitConstraint |
	InvarConstraint |
	FairnessConstraint |
	CtlSpecification  |
	LtlSpecification |
	InvarSpecification |
	IsaDeclaration
;

//Also the single keyword "VAR" is accepted (without anything else)
VariableDeclaration hidden(WS, SL_COMMENT):
	var="VAR" (vars+=VarBody)*;

IVariableDeclaration hidden(WS, SL_COMMENT):
	"IVAR" (vars+=VarBody)+;

FrozenVariableDeclaration  hidden(WS, SL_COMMENT):
	"FROZENVAR" (vars+=VarBody)+;

VarBody hidden(WS, SL_COMMENT):
	id=ID ":" type=Type ";";

DefineDeclaration hidden(WS, SL_COMMENT):
	define="DEFINE" (defineBodies+=DefineBody)*;

DefineBody hidden(WS, SL_COMMENT):
	var=VariableIdentifier ":=" assignment=SimpleExpression ";";

ConstantsDeclaration hidden(WS, SL_COMMENT):
	"CONSTANTS" constants+=ID ("," constants+=ID)* ";";

AssignConstraint hidden(WS, SL_COMMENT):
	{AssignConstraint} "ASSIGN" (bodies+=AssignBody)*;

AssignBody hidden(WS, SL_COMMENT):
	VarBodyAssign | InitBody | NextBody;

VarBodyAssign hidden(WS, SL_COMMENT):
	var=VariableIdentifier ":=" assignment=SimpleExpression ";";

InitBody hidden(WS, SL_COMMENT):
	"init" "(" var=VariableIdentifier ")" ":=" initial=SimpleExpression ";";

NextBody hidden(WS, SL_COMMENT):
	"next" "(" var=VariableIdentifier ")" ":=" next=NextExpression ";";

TransConstraint hidden(WS, SL_COMMENT):
	"TRANS" transExpression=SimpleExpression ";"?;

InitConstraint hidden(WS, SL_COMMENT):
	"INIT" initExpression=SimpleExpression ";"?;

InvarConstraint hidden(WS, SL_COMMENT):
	"INVAR" invarExpression=SimpleExpression ";"?;

FairnessConstraint hidden(WS, SL_COMMENT):
	FairnessExpression | JusticeExpression | CompassionExpression;

FairnessExpression hidden(WS, SL_COMMENT):
	"FAIRNESS" fairnessExpr=SimpleExpression ";"?;

JusticeExpression hidden(WS, SL_COMMENT):
	"JUSTICE" justiceExpr=SimpleExpression ";"?;

CompassionExpression hidden(WS, SL_COMMENT):
	"COMPASSION (" firstCompassionExpr=SimpleExpression "," secondCompassionExpr=SimpleExpression ")" ";"?;

CtlSpecification hidden(WS, SL_COMMENT) :
	("CTLSPEC" | "SPEC") (nameKeyWord?="NAME" name=ID ":=")? ctlExpression=CTLExpression ";"?;

LtlSpecification hidden(WS, SL_COMMENT) :
	"LTLSPEC" (nameId?="NAME" name=ID ":=")? ltlExpression=LTLExpression ";"?
;

CTLExpression hidden(WS, SL_COMMENT): simpleExpression=SimpleExpression;
LTLExpression hidden(WS, SL_COMMENT): simpleExpression=SimpleExpression;

InvarSpecification hidden(WS, SL_COMMENT) :
	"INVARSPEC" invarSpec=NextExpression ";" |
	"INVARSPEC" name=ID ":=" invarSpec=NextExpression ";"?
;

IsaDeclaration hidden(WS, SL_COMMENT): "ISA" id=ID;

Type hidden(WS, SL_COMMENT): SimpleType | ModuleType;

SimpleType hidden(WS, SL_COMMENT):
	  {BooleanType} "boolean"
	| {WordType} ("word" "[" wordNumber=NUMBER "]") 
	| {UnsignedWordType} ("unsigned" "word" "[" uWordNumber=NUMBER "]")
	| {SignedWordType} ("signed word" "[" signedNumber=NUMBER "]")
	| {EnumType} "{" val+=Val ("," val+=Val)* "}"
	| {IntervalType} (low = NUMBER ".." high = NUMBER)
	| {ArrayType} "array" lowerBound=NUMBER ".." upperBound=NUMBER "of" type=SimpleType
;

ModuleType hidden(WS, SL_COMMENT):
	  {AsyncrProcessType} ("process" module=[Module | ID] ("(" params+=SimpleExpression ("," params+=SimpleExpression)* ")")?)
	| {SyncrProcessType} (module=[Module| ID] ("(" params+=SimpleExpression ("," params+=SimpleExpression)* ")")?)
;

Val hidden(WS, SL_COMMENT): ID | NUMBER | BooleanConstant;

NextExpression hidden(WS, SL_COMMENT):
	simpleExpression=SimpleExpression
;

FormalParameter: id=ID;

VariableIdentifier hidden(WS, SL_COMMENT):
 TerminalVariableIdentifier ("." TerminalVariableIdentifier)*
| TerminalVariableIdentifier ("[" (NUMBER | TerminalVariableIdentifier) "]")+
| TerminalVariableIdentifier "[" NUMBER ":" NUMBER"]"
;

TerminalVariableIdentifier hidden(WS, SL_COMMENT): ID;

SimpleExpression hidden(WS, SL_COMMENT):
	InfixExpression;

InfixExpression:
	TerminalSimpleExpression (('U'|'V'|'S'|'T'|'->'|'<->'|'&'|'|'|'xor'|'xnor'|'='|'!='|'<'|'>'|'<='|'>='|'+'|'-'|'*'|'/'|'::'|'<<'|'>>'|'union'|'in'|'mod') TerminalSimpleExpression)*;

TerminalSimpleExpression:
	'!'? (
		'next'? '(' SimpleExpression ')'
	    | (('-' | '+' | 'EG' | 'EX' | 'EF' | 'AG' | 'AX' | 'AF' | 'X' | 'G' | 'F' | 'Y' | 'Z' | 'H' | 'O') SimpleExpression)
	    | CaseExpression
	    | VariableIdentifier
	    | NUMBER
		| NUMBER '..' NUMBER
		| BooleanConstant
		| 'self'
		| '{' SimpleExpression (',' SimpleExpression)* '}'
		| ('E' | 'A') '[' InfixExpression ']'
		| ('word1' | 'boo1') '(' SimpleExpression ')'
	)
;

CaseExpression hidden(WS, SL_COMMENT):
	'case'
	(CaseSimpleExpression ';')+
	'esac'
;

CaseSimpleExpression:
	SimpleExpression ':' SimpleExpression
;


BooleanConstant returns ecore::EBoolean: 'TRUE' | 'FALSE';

terminal NUMBER : INT;

terminal SL_COMMENT : '--' SL_COMMENT_BODY;
terminal fragment SL_COMMENT_BODY: !('\n'|'\r')* ('\r'? '\n')?;

terminal ID : ('A'..'Z'|'a'..'z'|'_') ('A'..'Z'|'a'..'z'|'_'|'0'..'9'|'$'|'#'|'-'|'.')*;